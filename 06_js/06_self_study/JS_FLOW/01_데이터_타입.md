# 01. 데이터 타입

<br>

## 1. Primitive Type vs Reference Type

### (1) 기본형과 참조형 비교

| 데이터 타입            | 차이점                           | 예시                                     |
| ---------------------- | -------------------------------- | ---------------------------------------- |
| Primitive Type(기본형) | 값을 그대로 할당                 | Number, String, Boolean, null, undefined |
| Reference Type(참조형) | 값이 저장된 주소값을 할당 (참조) | Object - Array, Function, RegExp         |

- 기본형 데이터는 같은 메모리 상에서 한 번 만들어진 값을 다른 곳에서 사용하려고 하면 같은 주소를 바라보면서 동일하게 사용된다.(즉, 같은 데이터(값)은 하나만 있다는 것이 기본형 데이터의 핵심!)

<br>

### (2) 기본형 데이터 할당 과정

- Case 01

```js
// 변수 a를 새로 선언하면 메모리에 데이터를 담을 공간을 확보한다.
// 확보한 공간의 주소 값을 변수명 a와 매칭시킨다.
var a; // 선언 과정

// 이후 a에 10을 할당하면 변수명 a를 찾아 해당 주소값을 찾아 그 주소로 이동해서 해당 공간에 10을 넣는다.
a = 10; // 할당 과정
```

- Case 02

```js
// 변수 b를 새로 선언하면 메모리에 데이터를 담을 공간을 확보한다.
// 확보한 공간의 주소 값을 변수명 b와 매칭시킨다.
// 그리고 할당된 데이터 'abc'를 변수명 b를 찾아 해당 주소값을 찾아 그 주소로 이동해서 해당 공간에 'abc을 넣는다.
var b = 'abc'; // 선언 과정, 할당 과정을 차례대로 진행
// 즉, var b = 'abc'; 는 "var b;"와 "b = 'abc'"를 한 줄로 작성한 것이다.

// b에 false를 할당하라고 하면 현재 가지고 있는 변수 중 b가 있는지 확인 후 해당 주소 값을 읽고 그 주소로 이동해서 해당 공간에 false를 넣는다.
// 만약 현재 가지고 있는 변수 중 b가 없는 경우 앞에서 살펴본 선언 + 할당 과정을 동일하게 수행하면 된다.
b = false;
```

- Case 03

```js
// 새롭게 선언된 변수명 c의 선언 + 할당 과정을 동일하게 우선 수행한다.
// 그 후 변수 b를 읽어 해당 주소에 있는 데이터 false를 가져와 변수 c에 해당하는 주소로 이동해 false 값을 넣는다.
var c = b;
console.log(b === c); // true, 변수 b가 가리키는 메모리 공간 상의 false와 변수 c가 가리키는 메모리 공간 상의 false는 완전히 같다. false는 단 하나 뿐만 값이기 때문이다.

// 이 때 변수 c에 20이라는 새로운 값을 할당하면 원래 있던 false 값이 20으로 변하는 것이 아니라 메모리 공간에 있던 false 대신에 20을 덮어 씌우는 것이다.
c = 20;
console.log(b !== c); // false, 그러므로 b와 c는 서로 완전히 다른 값이 되었다.
```

<br>

### (3) 참조형 데이터 할당 과정

- Case 01

```js
// 우선 변수 obj에 대해 선언 과정 수행
var obj = {
  a: 10,
  b: 'k'
}

// 할당 과정은 기본형 데이터일 때와 동작이 약간 다르다.
// 변수 obj의 object는 key와 value로 이루어져 있는데 이 둘의 관계도 기본형 데이터를 선언하고 할당할 때와 동일한 과정으로 데이터를 할당하게 된다.

// 우선 각 key와 value가 포함된 전체 내용을 담은 공간을 확보한다.
// 그 후 key에 해당하는 a와 b에 value로 할당될 공간을 각각 확보한다.
// 그리고 나서 각각의 주소값마다 기본형 데이터(10, 'k')를 할당한다.
// 기본형 데이터 할당 후 각 key와 value가 포함된 전체 내용을 담은 공간의 주소를 obj의 주소와 매칭시켜준다.
// 한 마디로 참조형 데이터는 기본형 데이터의 집합이라고 볼 수 있다.

// 이 때 obj2 라는 새로운 변수에 obj 변수를 할당하면 해당 값을 할당하는 것이 아니라 변수 obj가 가리키고 있는 주소값을 obj2에 할당하면 끝난다. 즉, 객체가 저장된 주소만 가져오면 되는 것이다.
var obj2 = obj;

// 그래서 obj2의 a에 10을 할당하는 것은 obj2에 저장된 주소값으로 이동 후 그 안에 있는 a의 value를 10으로 바꾸면 되는 것이다.
obj2.a = 10;
console.log(obj2.a); // 10

// obj2가 obj와 다른 새로운 객체를 만든 것이 아니라 원래 obj가 바라보고 있는 객체를 함께 바라보고 있기 때문에 obj2.a와 같은 값이 출력된다.
console.log(obj.a); // 10
console.log(obj === obj2); // true
```

- Case 02 - Nested한 객체

```js
var obj3 = {
  a: [1, 2, 3]
};
```

![01](https://user-images.githubusercontent.com/52685250/84587403-e5dcda00-ae59-11ea-952e-528c23c6f61c.png)

```js
obj3.a = 'new';
```

![02](https://user-images.githubusercontent.com/52685250/84587404-e70e0700-ae59-11ea-9971-105ab4677d89.png)