# :page_facing_up: Item19 ~ 23

<br>

## Item19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

### (1) 타입 추론 장점

- 타입스크립트를 처음 접한 개발자가 자바스크립트 코드를 포팅할 때 가장 먼저 하는 일은 타입 구문을 넣는 것이다.
  - 모든 변수를 선언할 때마다 타입을 명시해야 한다고 생각하지만 타입스크립트의 많은 타입 구문은 사실 불필요하다.
  - 타입이 추론이 된다면 명시적 타입 구문은 필요하지 않는다.

```typescript
let x: number = 12;
let x = 12; // 해당 코드를 마우스를 올리면 타입이 number로 이미 추론됨
```

- 타입 추론되면 리팩토링 역시 용이해진다.

```typescript
interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id; // 만약 이와 같이 작성하면 타입 오류가 발생할 것이다.
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```

- 참고로 위 코드 보다는 비구조화 할당문을 사용하는 것이 더 좋다.

```typescript
function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

<br>

### (2) 무조건 모든 변수에 타입을 정의하지 말자

- 타입스크립트는 최종 사용처까지 고려하여 타입을 추론하지 않는다.
  - 타입스크립트에서 변수의 타입은 일반적으로 처음 등장할 때 결정된다.
- 이상적인 타입스크립트 코드는 **함수/메서드 시그니처에 타입 구문을 포함**하지만, **함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다**.
  - 타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.

- 보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론된다.

```typescript
// Don't!
app.get('/health', (request: express.Request, response: express.Response) => {
  response.send('OK');
})

// Do!
app.get('/health', (request, response) => {
  response.send('OK');
})
```

<br>

### (3) 객체 리터럴 정의할 때 타입 추론

- 타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 상황이 존재한다. 객체 리터럴을 정의할 때를 살펴보자.

```typescript
const elmo: Product = {
  name: 'Elmo',
  id: '12345',
  price: 28.99,
}
```

- 위와 같이 타입을 명시하면 잉여 속성 체크가 동작한다.
  - 잉여 속성 체크는 특히 선택적 속성이 있는 타입의 오타 같은 오류를 잡는 데 효과적이다.
  - 그리고 변수가 사용되는 순간이 아닌 할당하는 시점에 오류가 표시되도록 해준다.
- 만약 타입 구문을 제거한다면 잉여 속성 체크가 동작하지 않고, 객체를 선언한 곳이 아니라 객체가 사용되는 곳에서 타입 오류가 발생한다.
  - 그러나 타입 구문을 제대로 명시한다면, 실제로 실수가 발생한 부분에 오류를 표시해준다.

```typescript
const elmo = {
  name: 'Elmo',
  id: '12345',
  price: 28.99,
}

logProduct(elmo); // 여기서 오류 발생!
```

<br>

### (4) 반환 타입 명시의 장점

---

#### :star: 오류 방지

- 함수의 반환에도 타입을 명시하여 **오류를 방지**할 수 있다.
  - 타입 추론이 가능할지라도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위해 타입 구문을 명시하는 게 좋다.

```typescript
const cache: { [ticker: string]: number } = {};

function getQuote(ticker: string) {
  if (ticker in cache) {
    return cache[ticker];
  }
    
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then(response => response.json())
    .then(quote => {
      cache[ticker] = quote;
      return quote;
    });
}
```

- 위 코드에는 오류가 존재하는데 `getQuote`는 항상 `Promise`를 return하므로 if 구문에는 `cache[ticker]`가 아니라 `Promise.resolve(cache[ticker])`가 반환되도록 해야 한다.
  - 실행해보면 오류는 `getQuote` 내부가 아닌 `getQuote`를 호출하는 코드에서 발생한다.

```typescript
// 함수 호출부
getQuote('MSFT').then(considerBuying);
// ~~~ 'number | Promise<any>' 형식에 'then' 속성이 없습니다.
// 'number' 형식에 'then' 속성이 없습니다.
```

- 이 때 의도된 반환 타입(`Promise<number>`)을 명시한다면, 정확한 위치에 오류가 표시된다.

```typescript
const cache: { [ticker: string]: number } = {};

function getQuote(ticker: string): Promise<number> {
  if (ticker in cache) {
    return cache[ticker]; // 'number' 형식은 'Promise<number>' 형식에 할당할 수 없습니다.
  }
}
```

- 반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.
  - `Promise`와 관련된 특정 오류를 피하는 데는 `async` 함수가 효과적이다.

---

#### :star: 함수에 대해 더욱 명확하게 알 수 있음

- 반환 타입을 명시하려면 구현하기 전에 입력 타입과 출력 타입이 무엇인지 알아야 한다.
  - 추후에 코드가 조금 변경되어도 그 함수의 시그니처는 쉽게 바뀌지 않는다.
  - 전체 타입 시그니처를 먼저 작성하면 구현에 맞추어 주먹구구식으로 시그니처가 작성되는 것을 방지하고 **원하는 모양을 얻게 된다.**

---

#### :star: 명명된 타입을 사용하기 위해서

```typescript
interface Vector2D {
  x: number;
  y: number;
}

function add(a: Vector2D, b: Vector2D) {
  return {
    x: a.x + b.x,
    y: a.y + b.y,
  }
}
```

- 위와 같이 반환 타입을 명시하지 않은 경우 `add` 함수의 반환 타입은 `{ x: number; y: number; }`로 추론된다.
  - 이런 경우 `Vector2D`와 호환되지만, 입력이 `Vector2D`인데 반해 출력은 `Vector2D`가 아니므로 사용자 입장에서 당황스러울 수 있다.
- **반환 타입을 명시하면 더욱 직관적인 표현이 된다.**
  - 그리고 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작성할 수 있어서, 더욱 자세한 설명이 가능하다.(feat. `TSDoc`)
  - 추론된 반환 타입이 복잡해질수록 명명된 타입을 제공하는 이점은 커진다.
- 린터를 사용하고 있다면 `eslint` 규칙 중 `no-inferrable-types`을 사용해서 작성된 모든 타입 구문이 정말로 필요한지 확인할 수 있다.

---

<br>

## Item20. 다른 타입에는 다른 변수 사용하기

(작성중...)
