# :page_facing_up: Item29 ~ 33

<br>

## Item29. 사용할 때는 너그럽게, 생성할 때는 엄격하게

- 함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.

---

- 예시) 3D 매핑 API - 카메라의 위치를 지정하고 경계 박스의 뷰포트를 계산

### :star: 사용할 때는 너그럽게

```typescript
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
```

- 일부 값은 건드리지 않으면서 동시에 다른 값을 설정할 수 있어야 하므로 `CameraOptions`의 필드는 모두 선택적이다.
- 게다가 `LngLat` 타입도 다양한 형테의 매개변수 타입을 정의하여 편의성을 제공하여 함수 호출을 쉽게 할 수 있다.

```typescript
interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}

type LngLat = { lgn: number; lat: number; } | { lon: number; lat: number; } | [number, number];
```

- 또한 `viewportForBounds` 함수는 위와 같은 자유로운 타입을 매개변수로 받는다.
  - `LngLat` 타입과 조합하면 `LngLatBounds`의 가능한 형태는 19가지 이상으로 매우 자유로운 타입이다.

```typescript
type LngLatBounds = { northeast: LngLat, southwest: LngLat } | [LngLat, LngLat] | [number, number, number, number];
```

<br>

### :star: 생성할 때는 엄격하게

```typescript
function focusOndFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const { center: { lat, lng }, zoom } = camera;
  // ~~~ ... 형식에 'lat' 속성이 없습니다.
  // ~~~ ... 형식에 'lng' 속성이 없습니다.
  zoom; // 타입이 number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

- 위 오류는 `lat`, `lng` 속성이 없고 `zoom` 속성만 존재하여 발생했고, `zoom`의 타입이 `number | undefined`로 추론되는 것도 역시 문제다.
- 근본적인 문제는 `viewportForBounds`의 타입 선언이 사용될 때뿐만 아니라 만들어질 때도 너무 자유롭다는 것이다.
- `camera` 값을 안전한 타입으로 사용하는 유일한 방법은 **유니온 타입의 각 요소별로 코드를 분기**하는 것이다.

- 유니온 타입의 요소별 분기를 위한 방법은 좌표를 위한 기본 형식을 구분하는 것이다.
  - 배열과 배열 같은 것의 구분을 위해 `LngLat`와 `LngLatLike`를 구분할 수 있다.
  - 또한 `setCamera` 함수가 매개변수로 받을 수 있도록, 완전하게 정의된 `Camera` 타입과 `Camera` 타입이 부분적으로 정의된 버전을 구분할 수도 있다.

```typescript
interface LngLat {
  lng: number;
  lat: number;
}

type LngLatLike = LngLat | { lon: number; lat: number; } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}

interface CameraOptions extends Omit<Partial<Camera>, 'center'> {
  center?: LngLatLike;
}

type LngLatBounds = { northeast: LngLatLike, southwest: LngLatLike } | [LngLatLike, LngLatLike] | [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```

<br>

## Item30. 문서에 타입 정보를 쓰지 않기

- 타입스크립트의 타입 구문 시스템은 간결하고, 구체적이며, 쉽게 읽을 수 있도록 설계되어있다.
  - 함수의 입력과 출력의 타입을 코드로 표현하는 것이 주석보다 더 나은 방법이라는 것은 자명하다.
- 누군가 강제하지 않는 이상 주석ㅇ은 코드와 동기화되지 않는다.
  - 주석 대신 타입 정보를 작성한다면 코드가 변경된다 하더라도 정보가 정확히 동기화된다.
- 특정 매개변수를 설명하고 싶다면 JSDoc의 `@param` 구문을 사용하면 된다.
- 값을 변경하지 않는다고 설명하는 주석도 좋지 않다.
  - 또한 매개변수르 변경하지 않는다는 주석도 사용하지 않는 것이 좋다.
  - 그 대신, `readonly`로 선언하여 타입스크립트가 규칙을 강제할 수 있게 하면 된다.
- 변수명에 타입 정보를 넣지 않도록 한다.
  - 예를 들어 변수명 `ageNum`으로 하는 것보다는 `age`로 하고, 그 타입이 `number`임을 명시하는게 좋다.
  - 그러나 단위가 있는 숫자들은 예외이다. 단위가 무엇인지 확실하지 않다면 변수명 또는 속성 이름에 단위를 포함할 수 있다.

---

- **주석과 변수명에 타입 정보를 적는 것은 피해야 한다.**
  - 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 된다.
- **타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.** (예를 드러 `timeMs` 또는 `temperatureC`)

---

<br>

## Item31. 타입 주변에 `null` 값 배치하기

(작성중...)
