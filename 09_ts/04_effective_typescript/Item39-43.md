# :page_facing_up: Item39 ~ 43

<br>

## Item39. `any`를 구체적으로 변형해서 사용하기

- `any` 타입의 값을 그대로 정규식이나 함수에 넣는 것을 권장하지 않는다.

```typescript
// bad!
function getLengthBad(array: any) {
  return array.length;
}

// good!
function getLength(array: any[]) {
  return array.length;
}
```

- `getLength` 함수와 같이 작성해야 하는 이유
  - 함수 내의 `array.length` 타입이 체크됨
  - 함수의 반환 타입이 `any` 대신 `number`로 추론됨
  - 함수 호출될 때 매개변수가 배열인지 체크됨
- 함수의 매개변수 구체화 예시

```typescript
function hasTwelveLetterKey(o: {[key: string]: any}) {
  for (const key in o) {
    if (key.length === 12) {
      return true;
    }
  }
    
  return false;
}
```

- 함수의 타입에 `any` 적용하는 예시

```typescript
type Fn0 = () => any; // 매개변수 없이 호출 가능한 모든 함수
type Fn1 = (arg: any) => any; // 매개변수 1개
type Fn2 = (...args: any[]) => any; // 모든 개수의 매개변수 ("Function" 타입과 동일)
```

```typescript
const numArgsBad = (...args: any) => args.length; // any를 반환
const numArgsGood = (...args: any[]) => args.length; // number를 반환
```

- `any`를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 한다.
- `any` 보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[id: string]: any}` 또는 `() => any` 처럼 구체적인 형태를 사용해야 한다.

<br>

## Item40. 함수 안으로 타입 단언문 감추기

- 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상황까지 고려해 가며 타입 정보를 힘들게 구성할 필요는 없다.
  - 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는 게 좋다.
  - 프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계이다.

### (1) `cacheLast`  함수 예시

```typescript
declare function cacheLast<T extends Function>(fn: T): T;
```

```typescript
declare function shallowEqual(a: any, b: any): boolean;

function cacheLast<T extends Function)(fn: T): T {
  let lastArgs: any[] | null = null;
  let lastResult: any;
    
  return function(...args: any[]) {
    // ~~~~~~~~~~~~~~~~~~~~~
    // '(...args: any[]) => any' 형식은 'T' 형식에 할당할 수 없습니다.
    if (!lastArgs || !shallowEqual(lastArgs, args)) {
      lastResult = fn(...args);
      lastArgs = args;
    }
    return lastResult;
  }
}
```

- 타입스크립트는 반환문에 있는 함수와 원본 함수에 있는 함수 `T` 타입이 어떤 관련이 있는지 알지 못하여 오류가 발생했다.
  - 그러나 결과적으로 원본 함수 `T` 타입과 동일한 매개변수로 호출되고 반환값 역시 예상한 결과가 되기 때문에, 타입 단언문을 추가해서 오류를 제거하는 것이 큰 문제가 되지는 않는다.

```typescript
function cacheLast<T extends Function)(fn: T): T {
  let lastArgs: any[] | null = null;
  let lastResult: any;
    
  return function(...args: any[]) {
    // ~~~~~~~~~~~~~~~~~~~~~
    // '(...args: any[]) => any' 형식은 'T' 형식에 할당할 수 없습니다.
    if (!lastArgs || !shallowEqual(lastArgs, args)) {
      lastResult = fn(...args);
      lastArgs = args;
    }
    return lastResult;
  } as unknown as T;
}
```

<br>

### (2) 객체 비교 `shallowObjectEqual` 함수 예시

```typescript
declare function shallowObjectEqual<T extends object>(a: T, b: T): boolean;
```

```typescript
declare function shallowEqual(a: any, b: any): boolean;

function shallowObjectEqual<T extends object>(a: T, b: T): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== (b as any)[k]) {
      return false;
    }
  }
    
  return Object.keys(a).length === Object.keys(b).length;
}
```

- `k in b` 구문으로 체크했기 때문에 `b as any` 타입 단언문은 안전하다.
- 객체가 같은지 체크하기 위해 객체 순회와 단언문이 코드에 직접 들어가는 것보다, 앞의 코드처럼 별도의 함수로 분리해 내는 것이 훨씬 좋은 설계이다.

<br>

## Item41. `any`의 진화를 이해하기

### :pushpin: 타입의 진화

- 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.

```typescript
function range(start: number, limit: number) {
  const out = []; // 타입이 any[]
  
  for (let i = start; i < limit; i++) {
    out.push(i); // out의 타입이 any[]
  }
    
  return out; // 타입이 number[]
}
```

- 또한 조건문에서는 분기에 따라 타입이 변할 수도 있다.
  - 만약 `noImplicitAny` 설정은 끈 경우에는 아래 추론되는 타입이 모두 `any`로 잡히게 된다.

```typescript
let val; // 타입이 any

if (Math.random() < 0.5) {
  val = /hello/;
  val; // 타입이 RegExp
} else {
  val = 12;
  val; // 타입이 number
}

val; // 타입이 number | RegExp
```

- `try/catch` 블록 안에서 변수를 할당할 때 변수의 초깃값이 `null`인 경우도 `any`의 진화가 일어난다.

```typescript
let val = null; // 타입이 any

try {
  somethingDangerous();
  val = 12;
  val; // 타입이 number
} catch (e) {
  console.warn('alas!');
}

val; // 타입이 number | null
```

---

:heavy_check_mark: <b>Check Point!</b>

- 타입의 진화는 값을 할당하거나 배열에 요소를 넣은 후에만 일어나기 때문에, 편집기에서는 이상하게 보일 수 있다.
- 할당이 일어난 줄의 타입을 조사해 봐도 여전히 `any` 또는 `any[]`로 보일 것이다.

---

- 암시적 `any` 타입은 어떤 값을 할당할 때만 `any` 타입의 진화가 일어난다.
  - 그리고 어떤 변수가 암시적 `any` 상태일 때 값을 읽으려고 하면 오류가 발생한다.
  - 또한 함수 호출을 거쳐도 진화하지 않는다.

```typescript
function makeSquares(start: number, limit: number) {
  const out = []; // 'out' 변수는 일부 위치에서 암시적으로 'any[]' 형식이다.
  
  range(start, limit).forEach(i => {
    out.push(i * i);
  });
    
  return out; // 'out' 변수에는 암시적으로 'any[]' 형식이 포함된다.
}
```

- 위 코드와 같이 루프로 순회하는 대신, 배열의 `map`, `filter` 메소드를 통해 단일 구문으로 배열을 생성하여 `any` 전체를 진화시키는 방법을 생각해볼 수 있다.
- **타입을 안전하게 지키기 위해서는 암시적 `any`를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 더 좋은 설계이다.**

<br>

## Item42. 모르는 타입의 값에는 `any` 대신 `unknown`을 사용하기

(작성중...)
