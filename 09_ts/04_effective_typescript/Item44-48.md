# :page_facing_up: Item44 ~ 48

<br>

## Item44. 타입 커버리지를 추적하여 타입 안전성 유지하기

- `npm`의 `type-coverage` 패키지를 활용하여 `any`를 추적할 수 있는 몇 가지 방법이 있다.

```bash
$ npx type-coverage
9985 / 10117 98.69%
```

- 위와 같은 결과는 해당 프로젝트의 10,117개 심벌 중 9,985개(98.69%)가 `any`가 아니거나 `any`의 별칭이 아닌 타입을 가지고 있음을 알 수 있다.

```bash
$ npx type-coverage --detail
path/to/code.ts:1:10 getColumnInfo
path/to/module.ts:7:1 pt2
```

- 위와 같이 `--detail` 플래그를 붙이면, `any` 타입이 있는 곳을 모두 출력해준다.
  - 이를 통해 미처 발견하지 못한 `any`의 근원지를 찾을 수도 있다.
- 서드파티 라이브러리로부터 비롯되는 ` any` 타입은 몇 가지 형태로 등장할 수 있지만 가장 극단적인 예는 전체 모듈이 `any` 타입을 부여하는 것이다.

```typescript
declare module 'my-module';
```

- 위와 같은 선언으로 `my-module`에서 어떤 것이든 오류 없이 import 할 수 있다.
  - import한 모든 심벌은 `any` 타입이고, import한 값이 사용되는 곳마다 `any` 타입을 양산하게 된다.

```typescript
import { someMethod, someSymbol } from 'my-module'; // 정상

const pt1 = {
  x: 1,
  y: 2,
}; // 타입이 {x: number, y: number}

const pt2 = someMethod(pt1, someSymbol); // 정상, pt2의 타입이 any
```

- 서드파티 라이브러리로부터 비롯되는 `any`의 또 다른 형태는 타입에 버그가 있는 경우이다.
  - 선언된 타입과 실제 반환된 타입이 맞지 않는다면 어쩔 수 없이 `any` 단언문을 사용해야 한다.
  - 그러나 나중에 라이브러리가 업데이트되어 함수의 선언문이 제대로 수정된다면 `any`를 제거해야 한다.

---

### :pushpin: 정리

- `noImplicityAny` 가 설정되어 있어도, 명시적 `any` 또는 서드파티 타입 선언(`@types`)을 통해 `any` 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 한다.
- 작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 한다. 추적함으로써 `any`의 사용을 줄여 나갈 수 있고 타입 안전성을 꾸준히 높일 수 있다.

---

<br>

## Item45. `devDependencies`에 `typescript`와 `@types` 추가하기

(작성중...)
